n_tr = round(length(dat)*0.9)
train = dat[1:n_tr]
valid = dat[(n_tr+1):length(dat)]
n_pred = length(valid)
res = vector()
# 7 period moving average:
for (i in seq(n_pred)){
print(i)
print(length(train))
temp = train[(length(train)-5):length(train)]
pred = mean(temp)
train = append(train,pred)
res = append(res,pred)
}
library(ggplot2)
library(reshape2)
final=data.frame(res=res,valid=valid,x=seq(length(res)))
dfm = melt(final,id.vars = 'x')
p <- ggplot(dfm, aes(x = x, y = value, colour = variable))
p + geom_line()
library(feather) # data import
library(data.table) # data handle
library(rpart) # decision tree method
library(party) # decision tree method
library(forecast) # forecasting methods
library(randomForest) # ensemble learning method
library(ggplot2) # visualizations
install.packages('randomForest')
library(feather) # data import
library(data.table) # data handle
library(rpart) # decision tree method
library(party) # decision tree method
library(forecast) # forecasting methods
library(randomForest) # ensemble learning method
library(ggplot2) # visualizations
install.packages('feather')
install.packages('rpart')
install.packages("rpart")
install.packages("party")
library(feather) # data import
library(data.table) # data handle
library(rpart) # decision tree method
library(party) # decision tree method
library(forecast) # forecasting methods
library(randomForest) # ensemble learning method
library(ggplot2) # visualizations
getwd()
setwd('Desktop/DaiLy_Learning/')
DT <- as.data.table(read_feather("DT_load_17weeks"))
DT
unique(DT[, date])
length(unique(DT[, date]))
n_date <- unique(DT[, date])
period <- 48
theme_ts <- theme(panel.border = element_rect(fill = NA,
colour = "grey10"),
panel.background = element_blank(),
panel.grid.minor = element_line(colour = "grey85"),
panel.grid.major = element_line(colour = "grey85"),
panel.grid.major.x = element_line(colour = "grey85"),
axis.text = element_text(size = 13, face = "bold"),
axis.title = element_text(size = 15, face = "bold"),
plot.title = element_text(size = 16, face = "bold"),
strip.text = element_text(size = 16, face = "bold"),
strip.background = element_rect(colour = "black"),
legend.text = element_text(size = 15),
legend.title = element_text(size = 16, face = "bold"),
legend.background = element_rect(fill = "white"),
legend.key = element_rect(fill = "white"))
# Train&Test Split:
data_train <- DT[date %in% n_date[1:21]]
data_test <- DT[date %in% n_date[22]]
data_train
dim(data_train)
dim(data_test)
ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
#Modeling
data_ts <- ts(data_train$value, freq = period * 7)
data_ts
data_ts <- ts(data_train$value, freq = period * 7) # TS object for training data
?stl
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series # apply the
decomp_ts
plot(decomp_ts)
?stl
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part) # ARIMA
trend_for <- as.vector(forecast(trend_fit, period)$mean) # trend forecast
trend_for
plot(trend_for)
?msts
?fourier
data_msts
#Reference: https://petolau.github.io/Ensemble-of-trees-for-forecasting-time-series/
library(feather) # data import
library(data.table) # data handle
library(rpart) # decision tree method
library(party) # decision tree method
library(forecast) # forecasting methods
library(randomForest) # ensemble learning method
library(ggplot2) # visualizations
#GGPLOT setting:
theme_ts <- theme(panel.border = element_rect(fill = NA,
colour = "grey10"),
panel.background = element_blank(),
panel.grid.minor = element_line(colour = "grey85"),
panel.grid.major = element_line(colour = "grey85"),
panel.grid.major.x = element_line(colour = "grey85"),
axis.text = element_text(size = 13, face = "bold"),
axis.title = element_text(size = 15, face = "bold"),
plot.title = element_text(size = 16, face = "bold"),
strip.text = element_text(size = 16, face = "bold"),
strip.background = element_rect(colour = "black"),
legend.text = element_text(size = 15),
legend.title = element_text(size = 16, face = "bold"),
legend.background = element_rect(fill = "white"),
legend.key = element_rect(fill = "white"))
#LoadData:
DT <- as.data.table(read_feather("DT_load_17weeks"))
#Info:
n_date <- unique(DT[, date]) # Unique dates
period <- 48
# Train&Test Split:
data_train <- DT[date %in% n_date[1:21]]
data_test <- DT[date %in% n_date[22]]
# Train Visualize:
ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
#Modeling
data_ts <- ts(data_train$value, freq = period * 7) # TS object for training data
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series # apply the
#Fit Trend:
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part) # ARIMA
trend_for <- as.vector(forecast(trend_fit, period)$mean) # trend forecast
data_msts <- msts(data_train$value, seasonal.periods = c(period, period*7))#Multi_Seaonal Time Series
data_msts
plot(data_msts)
K <- 2
fuur <- fourier(data_msts, K = c(K, K)) # Fourier features to model (Daily and Weekly)
plot(fuur)
N <- nrow(data_train)
window <- (N / period) - 1
decomp_ts[, c(1,3)]
head(decomp_ts[, c(1,3)])
new_load <- rowSums(decomp_ts[, c(1,3)]) # detrended original time series
lag_seas <- decomp_ts[1:(period*window), 1] # lag feature to model
matrix_train <- data.table(Load = tail(new_load, window*period),
fuur[(period + 1):N,],
Lag = lag_seas)
# create testing data matrix
test_lag <- decomp_ts[((period*window)+1):N, 1]
fuur_test <- fourier(data_msts, K = c(K, K), h = period)
matrix_test <- data.table(fuur_test,
Lag = test_lag)
matrix_test
dim(matrix_train)
dim(matrix_test)
head(matrix_train)
head(matrix_test)
head(data_msts)
head(fuur)
decomp_ts[, c(1,3)]
head(decomp_ts[, c(1,3)])
rowSums(decomp_ts[, c(1,3)]) # detrended original time series
dim(decomp_ts[, c(1,3)])
dim(rowSums(decomp_ts[, c(1,3)]) # detrended original time series)
)
new_load <- rowSums(decomp_ts[, c(1,3)]) # detrended original time series
dim(new_load)
new_load
length(new_load)
head(decomp_ts[, c(1,3)])
N_boot <- 100 # number of bootstraps
pred_mat <- matrix(0, nrow = N_boot, ncol = period)
for(i in 1:N_boot) {
matrixSam <- matrix_train[sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE)] # sampling with sampled ratio from 0.7 to 0.9
tree_bag <- rpart(Load ~ ., data = matrixSam,
control = rpart.control(minsplit = sample(2:3, 1),
maxdepth = sample(26:30, 1),
cp = sample(seq(0.0000009, 0.00001, by = 0.0000001), 1)))
# new data and prediction
pred_mat[i,] <- predict(tree_bag, matrix_test) + mean(trend_for)
}
1:(N-period),
1:(N-period)
sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE)
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
length(sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE))
dim(pred_mat)
melt(pred_mat)
pred_ave_rpart <- pred_melt_rpart[, .(value = median(value)), by = .(Var2)]
pred_ave_rpart[, Var1 := "RPART_Bagg"]
pred_melt_rpart <- data.table(melt(pred_mat))
pred_ave_rpart <- pred_melt_rpart[, .(value = median(value)), by = .(Var2)]
pred_ave_rpart[, Var1 := "RPART_Bagg"]
pred_ave_rpart
ggplot(pred_melt_rpart, aes(Var2, value, group = Var1)) +
geom_line(alpha = 0.75) +
geom_line(data = pred_ave_rpart, aes(Var2, value), color = "firebrick2", alpha = 0.9, size = 2) +
labs(x = "Time", y = "Load (kW)", title = "Bagging with RPART") +
theme_ts
head(pred_melt_rpart)
ggplot(pred_melt_rpart, aes(x=Var2, y=value, group = Var1)) +
geom_line(alpha = 0.75) +
geom_line(data = pred_ave_rpart, aes(Var2, value), color = "firebrick2", alpha = 0.9, size = 2) +
labs(x = "Time", y = "Load (kW)", title = "Bagging with RPART") +
theme_ts
ggplot(pred_melt_rpart, aes(x=Var2, y=value, group = Var1)) +
geom_line(alpha = 0.75)
ggplot(pred_melt_rpart, aes(x=Var2, y=value, group = Var1)) +
geom_line(alpha = 0.75) +
geom_line(data = pred_ave_rpart, aes(Var2, value), color = "firebrick2", alpha = 0.9, size = 2) +
labs(x = "Time", y = "Load (kW)", title = "Bagging with RPART")
ggplot(pred_melt_rpart, aes(x=Var2, y=value, group = Var1)) +
geom_line(alpha = 0.75) +
geom_line(data = pred_ave_rpart, aes(Var2, value), color = "firebrick2", alpha = 0.9, size = 2) +
labs(x = "Time", y = "Load (kW)", title = "Bagging with RPART") +
theme_ts
DT
head(data_train)
plot(data_train$value)
?plot(data_train$value,)
ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
ggplot(pred_melt_rpart, aes(x=Var2, y=value, group = Var1)) +
geom_line(alpha = 0.75) +
geom_line(data = pred_ave_rpart, aes(Var2, value), color = "firebrick2", alpha = 0.9, size = 2) +
labs(x = "Time", y = "Load (kW)", title = "Bagging with RPART") +
theme_ts
head(data_test)
ggplot(data_test, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
head(matrix_test)
head(fuur_test)
head(data_msts)
length(data_test)
dim(data_test)
pred_ave_rpart
ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()
data_test
mytest = data_test['value']
data_test[,'value']
mytest = data_test[,'value']
seq(1:dim(mytest)[2])
dim(mytest)
dim(mytest)[2]
seq(1:dim(mytest)[1])
mytest['Var'] = seq(1:dim(mytest)[1])
seq(1:dim(mytest)[1])
dim(mytest)
seq(1:dim(mytest)[1])
mytest['Var'] = seq(1:dim(mytest)[1])
mytest = as.data.frame(mytest)
mytest['Var'] = seq(1:dim(mytest)[1])
mytest
ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()+geom_line(mytest,aes(x=Var,y=value))
dim(pred_ave_rpart)
ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()
colnames(mytest)
colnames(mytest) = c('target','var')
ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()+geom_line(mytest,aes(x=var,y=target))
ggplot()+geom_line(pred_ave_rpart,aes(x=Var2,y=value))+geom_line(mytest,aes(x=var,y=target))
ggplot()+geom_line(pred_ave_rpart,aes(x=Var2,y=value))
ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()
ggplot(mytest,aes(x=var,y=target))+geom_line()
ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()
a=ggplot(pred_ave_rpart,aes(x=Var2,y=value))+geom_line()
b=ggplot(mytest,aes(x=var,y=target))+geom_line()
require(gridExtra)
grid.arrange(a, b, ncol=2)
head(pred_ave_rpart)
colnames(pred_ave_rpart) = c('x','y','group')
mytest = data_test[,'value']
mytest = as.data.frame(mytest)
mytest['Var'] = seq(1:dim(mytest)[1])
mytest['group'] = 'label'
head(mytest)
colnames(mytest) = c('y','x','group')
head(mytest)
mytest = mytest[,c('x','y','group')]
final_vis = rbind(pred_ave_rpart,mytest)
head(final_vis)
ggplot(final_vis,aes(x=x,y=y,group=group))+geom_line()
ggplot(final_vis,aes(x=x,y=y,group=group,color=group))+geom_line()
DT <- read_feather("DT_load_17weeks")
class(DT)
DT
?read_feather
DT <- as.data.frame(read_feather("DT_load_17weeks"))
head(DT)
#Info:
n_date <- unique(DT[, date]) # Unique dates
period <- 48
DT <- as.data.table(read_feather("DT_load_17weeks"))
# DT <- as.data.frame(read_feather("DT_load_17weeks"))
#Info:
n_date <- unique(DT[, date]) # Unique dates
period <- 48
# Train&Test Split:
data_train <- DT[date %in% n_date[1:21]]
data_test <- DT[date %in% n_date[22]]
# Train Visualize:
ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
ggplot(data_test, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
# Train Visualize:
trp = ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
tsp = ggplot(data_test, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
library(gridExtra)
grid.arrange(trp,tsp,ncol=2)
grid.arrange(trp,tsp,nrow=2)
dim(data_train)
period * 7
?ts
a=ts(data_train$value, freq = period * 7) # TS object for training data
b=ts(data_train$value, frequencu = period * 7)
b=ts(data_train$value, frequency = period * 7)
a==b
head(data_train)
head(data_train,period * 7)
period
head(data_train,48)
head(data_train,49)
data_ts <- ts(data_train$value, freq = period * 7) # TS object for training data, frequency=number of observations per unit of time.
head(data_ts)
data_ts
plot(data_ts)
length(data_ts)
dim(data_train)
data_ts
1008/(period * 7)
stl(data_ts, s.window = "periodic", robust = TRUE)
head(stl(data_ts, s.window = "periodic", robust = TRUE))
plot(decomp_ts)
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
plot(decomp_ts)
forecast(trend_fit, period)
a=forecast(trend_fit, period)
plot(a)
?msts
c(period, period*7)
class(data_msts)
class(trend_part)
?fourier
fuur <- fourier(data_msts, K = c(K, K))
fuur
#Reference: https://petolau.github.io/Ensemble-of-trees-for-forecasting-time-series/
library(feather) # data import
library(data.table) # data handle
library(rpart) # decision tree method
library(party) # decision tree method
library(forecast) # forecasting methods
library(randomForest) # ensemble learning method
library(ggplot2) # visualizations
library(gridExtra)
#LoadData:
DT <- as.data.table(read_feather("DT_load_17weeks"))
# DT <- as.data.frame(read_feather("DT_load_17weeks"))
#Info:
n_date <- unique(DT[, date]) # Unique dates
period <- 48 # 48 records per day
# Train&Test Split:
data_train <- DT[date %in% n_date[1:21]]
data_test <- DT[date %in% n_date[22]]
# Train Visualize:
trp = ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
tsp = ggplot(data_test, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
grid.arrange(trp,tsp,nrow=2)
#Modeling
data_ts <- ts(data_train$value, freq = period * 7) # TS object for training data, frequency=number of observations per unit of time.
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
#Fit Trend and Find Features:
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part) # ARIMA
trend_for <- as.vector(forecast(trend_fit, period)$mean) # trend forecast
data_msts <- msts(data_train$value, seasonal.periods = c(period, period*7))#Multi_Seaonal Time Series
# Fourier features to model (Daily and Weekly)
K <- 2
fuur <- fourier(data_msts, K = c(K, K))
fuur
head(decomp_ts[,1])
decomp_ts
head(decomp_ts)
period*window
dim(data_train)
#Reference: https://petolau.github.io/Ensemble-of-trees-for-forecasting-time-series/
library(feather) # data import
library(data.table) # data handle
library(rpart) # decision tree method
library(party) # decision tree method
library(forecast) # forecasting methods
library(randomForest) # ensemble learning method
library(ggplot2) # visualizations
library(gridExtra)
#LoadData:
DT <- as.data.table(read_feather("DT_load_17weeks"))
# DT <- as.data.frame(read_feather("DT_load_17weeks"))
#Info:
n_date <- unique(DT[, date]) # Unique dates
period <- 48 # 48 records per day
# Train&Test Split:
data_train <- DT[date %in% n_date[1:21]]
data_test <- DT[date %in% n_date[22]]
# Train Visualize:
trp = ggplot(data_train, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
tsp = ggplot(data_test, aes(date_time, value)) +
geom_line() +
labs(x = "Date", y = "Load (kW)") +
theme_ts
grid.arrange(trp,tsp,nrow=2)
#Modeling
data_ts <- ts(data_train$value, freq = period * 7) # TS object for training data, frequency=number of observations per unit of time.
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
#Fit Trend and Find Features:
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part) # ARIMA
trend_for <- as.vector(forecast(trend_fit, period)$mean) # trend forecast
data_msts <- msts(data_train$value, seasonal.periods = c(period, period*7))#Multi_Seaonal Time Series
# Fourier features to model (Daily and Weekly)
K <- 2
fuur <- fourier(data_msts, K = c(K, K))
N <- nrow(data_train)
window <- (N / period) - 1
new_load <- rowSums(decomp_ts[, c(1,3)]) # detrended original time series
lag_seas <- decomp_ts[1:(period*window), 1] # lag feature to model
matrix_train <- data.table(Load = tail(new_load, window*period),
fuur[(period + 1):N,],
Lag = lag_seas)
# create testing data matrix
test_lag <- decomp_ts[((period*window)+1):N, 1]
fuur_test <- fourier(data_msts, K = c(K, K), h = period)
matrix_test <- data.table(fuur_test,
Lag = test_lag)
### Modeling:
N_boot <- 100 # number of bootstraps
pred_mat <- matrix(0, nrow = N_boot, ncol = period)
for(i in 1:N_boot) {
matrixSam <- matrix_train[sample(1:(N-period),
floor((N-period) * sample(seq(0.7, 0.9, by = 0.01), 1)),
replace = TRUE)] # sampling with sampled ratio from 0.7 to 0.9
tree_bag <- rpart(Load ~ ., data = matrixSam,
control = rpart.control(minsplit = sample(2:3, 1),
maxdepth = sample(26:30, 1),
cp = sample(seq(0.0000009, 0.00001, by = 0.0000001), 1)))
# new data and prediction
pred_mat[i,] <- predict(tree_bag, matrix_test) + mean(trend_for)
}
# Take the median:
pred_melt_rpart <- data.table(melt(pred_mat))
pred_ave_rpart <- pred_melt_rpart[, .(value = median(value)), by = .(Var2)]
pred_ave_rpart[, Var1 := "RPART_Bagg"]
# Plot:
ggplot(pred_melt_rpart, aes(x=Var2, y=value, group = Var1)) +
geom_line(alpha = 0.75) +
geom_line(data = pred_ave_rpart, aes(Var2, value), color = "firebrick2", alpha = 0.9, size = 2) +
labs(x = "Time", y = "Load (kW)", title = "Bagging with RPART") +
theme_ts
window*period
test_lag
